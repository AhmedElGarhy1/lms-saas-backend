/* DO NOT EDIT, file generated by generate-i18n-args.ts */

/* eslint-disable */
/* prettier-ignore */
import { TranslationArgs, TranslationKey } from './i18n-args.generated';
import { I18nPath } from './i18n.generated';

/**
 * Branded type for raw text strings that are NOT translation keys
 * Use this for non-translatable values like format names, IDs, etc.
 * Regular strings are automatically compatible with this type.
 * 
 * @example
 * ```ts
 * // ✅ Regular string works automatically (treated as RawText)
 * resource: 'CSV'
 * 
 * // ✅ Translation key - full IntelliSense
 * resource: 't.common.resources.user'
 * ```
 */
export type RawText = string & { __rawText?: never };

/**
 * Type for translatable arguments - can be either a translation key or raw text
 * Regular strings are automatically compatible (treated as RawText),
 * while translation keys get full IntelliSense support.
 *
 * @example
 * ```ts
 * // ✅ Translation key - full IntelliSense
 * resource: 't.common.resources.user'
 *
 * // ✅ Regular string - works automatically (no cast needed)
 * resource: 'CSV'
 * 
 * // ✅ Number - works as-is
 * count: 5
 * ```
 */
export type TranslatableArg = I18nPath | RawText;

/**
 * Type mapping that maps translation keys to their argument types
 * This enables TypeScript to enforce correct arguments per key
 */
export type KeyArgs<K extends TranslationKey> = K extends keyof TranslationArgs
  ? TranslationArgs[K]
  : {};

/**
 * Helper type to extract argument type for a given I18nPath
 * I18nPath already includes the 't.' prefix, so we can directly check against TranslationArgs
 * Returns the argument type if the key exists, or a flexible type for unknown keys
 */
export type PathArgs<P extends I18nPath> = P extends keyof TranslationArgs
  ? TranslationArgs[P]
  : Record<string, TranslatableArg | number>; // Flexible type for keys not in TranslationArgs (TranslatableArg = I18nPath | RawText)

/**
 * Helper type to check if PathArgs is empty (no arguments needed)
 * An empty PathArgs means the translation key doesn't require any arguments
 */
type IsEmptyArgs<T> = [keyof T] extends [never] ? true : false;

/**
 * Helper type for optional args that are required when the key needs them
 * - If PathArgs<P> is empty (Record<string, never>), args are optional (undefined allowed)
 * - If PathArgs<P> has properties, args are required (cannot be undefined)
 *
 * This ensures type safety: args are required when the translation key needs them,
 * but optional when the key doesn't need any arguments.
 *
 * @example
 * ```ts
 * // Key with no args - OptionalArgs allows undefined
 * OptionalArgs<'t.success.roleAssigned'> // Record<string, never> | undefined
 *
 * // Key with args - OptionalArgs requires the args
 * OptionalArgs<'t.errors.notFound.generic'> // { resource: TranslatableArg | number } (required)
 * ```
 */
export type OptionalArgs<P extends I18nPath> =
  IsEmptyArgs<PathArgs<P>> extends true
    ? PathArgs<P> | undefined // Empty - optional
    : PathArgs<P>; // Has args - required
