/* DO NOT EDIT, file generated by generate-i18n-args.ts */

/* eslint-disable */
/* prettier-ignore */
import { TranslationArgs, TranslationKey } from './i18n-args.generated';
import { I18nPath } from './i18n.generated';

/**
 * Type for translatable arguments - all string arguments must be translation keys (I18nPath)
 *
 * For non-translation values (like format names, IDs, etc.), cast them as I18nPath
 * to maintain type safety while allowing necessary exceptions.
 *
 * @example
 * ```ts
 * // ✅ Translation key - full IntelliSense
 * resource: 't.common.labels.user'
 *
 * // ✅ Non-translation value - explicit casting required
 * resource: 'CSV' as I18nPath
 *
 * // ❌ Accidental raw string - type error
 * resource: 'User'
 * ```
 */
export type TranslatableArg = I18nPath;

/**
 * Type mapping that maps translation keys to their argument types
 * This enables TypeScript to enforce correct arguments per key
 */
export type KeyArgs<K extends TranslationKey> = K extends keyof TranslationArgs
  ? TranslationArgs[K]
  : {};

/**
 * Helper type to extract argument type for a given I18nPath
 * I18nPath already includes the 't.' prefix, so we can directly check against TranslationArgs
 * Returns the argument type if the key exists, or a flexible type for unknown keys
 */
export type PathArgs<P extends I18nPath> = P extends keyof TranslationArgs
  ? TranslationArgs[P]
  : Record<string, TranslatableArg | number>; // Flexible type for keys not in TranslationArgs

/**
 * Helper type to check if PathArgs is empty (no arguments needed)
 * An empty PathArgs means the translation key doesn't require any arguments
 */
type IsEmptyArgs<T> = [keyof T] extends [never] ? true : false;

/**
 * Helper type for optional args that are required when the key needs them
 * - If PathArgs<P> is empty (Record<string, never>), args are optional (undefined allowed)
 * - If PathArgs<P> has properties, args are required (cannot be undefined)
 *
 * This ensures type safety: args are required when the translation key needs them,
 * but optional when the key doesn't need any arguments.
 *
 * @example
 * ```ts
 * // Key with no args - OptionalArgs allows undefined
 * OptionalArgs<'t.success.roleAssigned'> // Record<string, never> | undefined
 *
 * // Key with args - OptionalArgs requires the args
 * OptionalArgs<'t.errors.notFound.generic'> // { resource: I18nPath | number } (required)
 * ```
 */
export type OptionalArgs<P extends I18nPath> =
  IsEmptyArgs<PathArgs<P>> extends true
    ? PathArgs<P> | undefined // Empty - optional
    : PathArgs<P>; // Has args - required
