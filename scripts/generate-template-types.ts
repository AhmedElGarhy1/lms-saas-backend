import { readdirSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';

/**
 * Auto-generated template type generator
 * Scans src/i18n/notifications/en/ directory and generates TypeScript union type
 * for all available template paths with channel prefixes.
 */

const locales = ['en', 'ar'];
const baseLocale = 'en'; // Only scan 'en' for template paths
const templatesDir = join(process.cwd(), 'src/i18n/notifications', baseLocale);
const outputFile = join(
  process.cwd(),
  'src/modules/notifications/types/templates.generated.ts',
);

// Channel folders and their extensions
const CHANNEL_EXTENSIONS: Record<string, string[]> = {
  email: ['.hbs'],
  sms: ['.txt'],
  whatsapp: ['.txt'],
  'in-app': ['.json'],
  push: ['.txt'], // Reserved for future use
};

/**
 * Recursively collect all template files from a channel folder
 * @param dir - Directory to scan
 * @param channelPrefix - Channel prefix (e.g., 'email', 'sms')
 * @param base - Base path for template identifier
 * @returns Array of template paths with channel prefix (e.g., 'email/auth/otp-sent')
 */
function collectChannelTemplates(
  dir: string,
  channelPrefix: string,
  base: string = '',
): string[] {
  if (!existsSync(dir)) {
    return [];
  }

  const extensions = CHANNEL_EXTENSIONS[channelPrefix] || [
    '.hbs',
    '.txt',
    '.json',
  ];

  return readdirSync(dir, { withFileTypes: true }).flatMap((entry) => {
    const path = base ? `${base}/${entry.name}` : entry.name;

    if (entry.isDirectory()) {
      return collectChannelTemplates(
        join(dir, entry.name),
        channelPrefix,
        path,
      );
    }

    // Check if file has matching extension for this channel
    const hasMatchingExtension = extensions.some((ext) =>
      entry.name.endsWith(ext),
    );

    if (hasMatchingExtension) {
      // Remove extension and add channel prefix
      const templateName = path.replace(/\.(hbs|txt|json)$/, '');
      return [`${channelPrefix}/${templateName}`];
    }

    return [];
  });
}

/**
 * Collect all templates from all channel folders
 * @param templatesDir - Base templates directory
 * @returns Array of all template paths with channel prefixes
 */
function collectAllTemplates(templatesDir: string): string[] {
  const allTemplates: string[] = [];

  // Scan each channel folder
  for (const channel of Object.keys(CHANNEL_EXTENSIONS)) {
    const channelDir = join(templatesDir, channel);
    if (existsSync(channelDir)) {
      const channelTemplates = collectChannelTemplates(channelDir, channel);
      allTemplates.push(...channelTemplates);
    }
  }

  return allTemplates;
}

/**
 * Extract base template paths (without channel prefix)
 * Example: 'email/auth/otp-sent' ‚Üí 'auth/otp-sent'
 */
function extractBasePaths(templates: string[]): string[] {
  const basePaths = new Set<string>();

  for (const template of templates) {
    // Remove channel prefix (e.g., 'email/', 'sms/')
    const parts = template.split('/');
    if (parts.length > 1) {
      // Join everything after channel prefix
      const basePath = parts.slice(1).join('/');
      basePaths.add(basePath);
    }
  }

  return Array.from(basePaths).sort();
}

/**
 * Generate TypeScript type definition
 */
function generateTypeDefinition(
  templates: string[],
  basePaths: string[],
): string {
  if (templates.length === 0) {
    return `// Auto-generated. Do not edit.
// This file is generated by scripts/generate-template-types.ts

export type NotificationTemplatePath = never;
export type TemplateBasePath = never;
`;
  }

  const sortedTemplates = [...templates].sort();
  const sortedBasePaths = [...basePaths].sort();

  const typeDef = `// Auto-generated. Do not edit.
// This file is generated by scripts/generate-template-types.ts
// Run 'npm run generate:templates' to regenerate

export type NotificationTemplatePath =
  | ${sortedTemplates.map((t) => `'${t}'`).join('\n  | ')};

export type TemplateBasePath =
  | ${sortedBasePaths.map((b) => `'${b}'`).join('\n  | ')};
`;

  return typeDef;
}

/**
 * Main execution
 */
function main() {
  console.log('üîç Scanning template directory...');
  console.log(`   Directory: ${templatesDir}`);

  const templates = collectAllTemplates(templatesDir);

  if (templates.length === 0) {
    console.warn('‚ö†Ô∏è  No templates found!');
    process.exit(1);
  }

  console.log(`‚úÖ Found ${templates.length} template(s):`);
  templates.forEach((template) => {
    console.log(`   - ${template}`);
  });

  const basePaths = extractBasePaths(templates);
  console.log(`\n‚úÖ Found ${basePaths.length} base path(s):`);
  basePaths.forEach((basePath) => {
    console.log(`   - ${basePath}`);
  });

  const typeDef = generateTypeDefinition(templates, basePaths);

  writeFileSync(outputFile, typeDef, 'utf-8');

  console.log(`\n‚úÖ Generated type definition:`);
  console.log(`   ${outputFile}`);
  console.log(`\nüìù Template paths are now type-safe!`);
}

main();
