import * as fs from 'fs';
import * as path from 'path';

/**
 * Extract ICU placeholders from a translation string
 * Supports: {key}, {key, number}, {key, plural, ...}, etc.
 */
function extractPlaceholders(str: string): Set<string> {
  const placeholders = new Set<string>();

  // Match ICU placeholders: {key}, {key, format}, {key, plural, ...}
  // This regex matches { followed by key name, optionally followed by comma and format
  const regex = /\{([a-zA-Z_][a-zA-Z0-9_]*)(?:,\s*[^}]+)?\}/g;
  let match;

  while ((match = regex.exec(str)) !== null) {
    const key = match[1];
    placeholders.add(key);
  }

  return placeholders;
}

/**
 * Flatten nested object keys to dot notation
 */
function flattenKeys(obj: any, prefix = ''): Record<string, string> {
  const result: Record<string, string> = {};

  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;

    if (typeof value === 'string') {
      result[fullKey] = value;
    } else if (
      typeof value === 'object' &&
      value !== null &&
      !Array.isArray(value)
    ) {
      Object.assign(result, flattenKeys(value, fullKey));
    }
  }

  return result;
}

/**
 * Generate argument types from translation files
 */
function generateArgumentTypes() {
  const translationsPath = path.join(__dirname, '../src/i18n/en/t.json');
  const translations = JSON.parse(fs.readFileSync(translationsPath, 'utf-8'));

  // Flatten the nested structure to dot notation
  const flatTranslations = flattenKeys(translations);

  // Extract placeholders for each translation key
  const argsMap: Record<string, string[]> = {};

  for (const [key, value] of Object.entries(flatTranslations)) {
    if (typeof value === 'string') {
      const placeholders = extractPlaceholders(value);
      if (placeholders.size > 0) {
        // Convert to array and sort for consistent output
        argsMap[key] = Array.from(placeholders).sort();
      }
    }
  }

  // Generate TypeScript type definitions
  const typeDefinitions: string[] = [];
  typeDefinitions.push(
    '/* DO NOT EDIT, file generated by generate-i18n-args.ts */',
  );
  typeDefinitions.push('');
  typeDefinitions.push('/* eslint-disable */');
  typeDefinitions.push('/* prettier-ignore */');
  typeDefinitions.push('');
  typeDefinitions.push('import { I18nPath } from "./i18n.generated";');
  typeDefinitions.push('import { TranslatableArg } from "./i18n-type-map.generated";');
  typeDefinitions.push('');
  typeDefinitions.push('/**');
  typeDefinitions.push(' * Argument types for translation keys');
  typeDefinitions.push(' * Maps translation key to its required arguments');
  typeDefinitions.push(' * ');
  typeDefinitions.push(
    ' * String arguments use TranslatableArg (I18nPath | RawText) to preserve IntelliSense for translation keys.',
  );
  typeDefinitions.push(
    ' * Regular strings work automatically (treated as RawText), no casting needed.',
  );
  typeDefinitions.push(' */');
  typeDefinitions.push('export type TranslationArgs = {');

  // Sort keys for consistent output
  const sortedKeys = Object.keys(argsMap).sort();

  for (const key of sortedKeys) {
    const args = argsMap[key];
    // Use TranslatableArg for string arguments to preserve IntelliSense for translation keys
    // Regular strings work automatically (treated as RawText), numbers remain as number type
    const argsType = args
      .map((arg) => `${arg}: TranslatableArg | number`)
      .join('; ');
    typeDefinitions.push(`  't.${key}': { ${argsType} };`);
  }

  typeDefinitions.push('};');
  typeDefinitions.push('');
  typeDefinitions.push('/**');
  typeDefinitions.push(
    ' * Union type of all translation keys that require arguments',
  );
  typeDefinitions.push(' */');
  typeDefinitions.push(
    'export type TranslationKey = keyof TranslationArgs | string;',
  );
  typeDefinitions.push('');

  // Write to file
  const outputPath = path.join(
    __dirname,
    '../src/generated/i18n-args.generated.ts',
  );
  fs.writeFileSync(outputPath, typeDefinitions.join('\n'), 'utf-8');

  console.log(
    `✅ Generated argument types for ${sortedKeys.length} translation keys`,
  );
  console.log(`   Output: ${outputPath}`);
}

// Run the generator
try {
  generateArgumentTypes();
} catch (error) {
  console.error('❌ Error generating argument types:', error);
  process.exit(1);
}
