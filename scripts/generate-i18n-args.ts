import * as fs from 'fs';
import * as path from 'path';

/**
 * Extract ICU placeholders from a translation string
 * Supports: {key}, {key, number}, {key, plural, ...}, etc.
 */
function extractPlaceholders(str: string): Set<string> {
  const placeholders = new Set<string>();

  // Match ICU placeholders: {key}, {key, format}, {key, plural, ...}
  // This regex matches { followed by key name, optionally followed by comma and format
  const regex = /\{([a-zA-Z_][a-zA-Z0-9_]*)(?:,\s*[^}]+)?\}/g;
  let match;

  while ((match = regex.exec(str)) !== null) {
    const key = match[1];
    placeholders.add(key);
  }

  return placeholders;
}

/**
 * Flatten nested object keys to dot notation
 */
function flattenKeys(obj: any, prefix = ''): Record<string, string> {
  const result: Record<string, string> = {};

  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;

    if (typeof value === 'string') {
      result[fullKey] = value;
    } else if (
      typeof value === 'object' &&
      value !== null &&
      !Array.isArray(value)
    ) {
      Object.assign(result, flattenKeys(value, fullKey));
    }
  }

  return result;
}

/**
 * Generate argument types from translation files
 */
function generateArgumentTypes() {
  const translationsPath = path.join(__dirname, '../src/i18n/en/t.json');
  const translations = JSON.parse(fs.readFileSync(translationsPath, 'utf-8'));

  // Flatten the nested structure to dot notation
  const flatTranslations = flattenKeys(translations);

  // Extract placeholders for each translation key
  // Include ALL keys, even those without placeholders (they'll have Record<string, never>)
  const argsMap: Record<string, string[] | null> = {};

  for (const [key, value] of Object.entries(flatTranslations)) {
    if (typeof value === 'string') {
      const placeholders = extractPlaceholders(value);
      if (placeholders.size > 0) {
        // Convert to array and sort for consistent output
        argsMap[key] = Array.from(placeholders).sort();
      } else {
        // Mark key as having no args (null means no placeholders)
        argsMap[key] = null;
      }
    }
  }

  // Generate TypeScript type definitions
  const typeDefinitions: string[] = [];
  typeDefinitions.push(
    '/* DO NOT EDIT, file generated by generate-i18n-args.ts */',
  );
  typeDefinitions.push('');
  typeDefinitions.push('/* eslint-disable */');
  typeDefinitions.push('/* prettier-ignore */');
  typeDefinitions.push('');
  typeDefinitions.push('import { I18nPath } from "./i18n.generated";');
  typeDefinitions.push('');
  typeDefinitions.push('/**');
  typeDefinitions.push(' * Argument types for translation keys');
  typeDefinitions.push(' * Maps translation key to its required arguments');
  typeDefinitions.push(
    ' * Keys without placeholders use Record<string, never>',
  );
  typeDefinitions.push(' * ');
  typeDefinitions.push(
    ' * ESLint validates that dot-separated strings are valid I18nPath values.',
  );
  typeDefinitions.push(' */');
  typeDefinitions.push('export type TranslationArgs = {');

  // Sort keys for consistent output
  const sortedKeys = Object.keys(argsMap).sort();

  for (const key of sortedKeys) {
    const args = argsMap[key];
    if (args === null) {
      // Key has no placeholders - use Record<string, never>
      typeDefinitions.push(`  't.${key}': Record<string, never>;`);
    } else {
      // Use string for arguments - ESLint handles validation
      const argsType = args.map((arg) => `${arg}: string`).join('; ');
      typeDefinitions.push(`  't.${key}': { ${argsType} };`);
    }
  }

  typeDefinitions.push('};');
  typeDefinitions.push('');

  // Write to file
  const outputPath = path.join(
    __dirname,
    '../src/generated/i18n-args.generated.ts',
  );
  fs.writeFileSync(outputPath, typeDefinitions.join('\n'), 'utf-8');

  const keysWithArgs = sortedKeys.filter((k) => argsMap[k] !== null).length;
  const keysWithoutArgs = sortedKeys.filter((k) => argsMap[k] === null).length;
  console.log(
    `✅ Generated argument types for ${sortedKeys.length} translation keys`,
  );
  console.log(`   - ${keysWithArgs} keys with arguments`);
  console.log(`   - ${keysWithoutArgs} keys without arguments`);
  console.log(`   Output: ${outputPath}`);

  // Generate i18n-type-map.generated.ts with type helpers
  generateTypeMap();
}

/**
 * Generate type map file with PathArgs, OptionalArgs, and TranslationMessage types
 */
function generateTypeMap() {
  const typeMapDefinitions: string[] = [];
  typeMapDefinitions.push(
    '/* DO NOT EDIT, file generated by generate-i18n-args.ts */',
  );
  typeMapDefinitions.push('');
  typeMapDefinitions.push('/* prettier-ignore */');
  typeMapDefinitions.push(
    'import { TranslationArgs } from "./i18n-args.generated";',
  );
  typeMapDefinitions.push('import { I18nPath } from "./i18n.generated";');
  typeMapDefinitions.push('');
  typeMapDefinitions.push('/**');
  typeMapDefinitions.push(
    ' * PathArgs extracts argument types for a given translation key.',
  );
  typeMapDefinitions.push(
    ' * ESLint validates that dot-separated strings in arguments are valid I18nPath values.',
  );
  typeMapDefinitions.push(' */');
  typeMapDefinitions.push(
    'export type PathArgs<P extends I18nPath> = P extends keyof TranslationArgs',
  );
  typeMapDefinitions.push('  ? TranslationArgs[P]');
  typeMapDefinitions.push('  : Record<string, never>;');
  typeMapDefinitions.push('');
  typeMapDefinitions.push('/**');
  typeMapDefinitions.push(
    ' * Helper type to check if PathArgs is empty (no arguments needed)',
  );
  typeMapDefinitions.push(
    " * An empty PathArgs means the translation key doesn't require any arguments",
  );
  typeMapDefinitions.push(' */');
  typeMapDefinitions.push('export type IsEmptyPathArgs<P extends I18nPath> =');
  typeMapDefinitions.push(
    '  PathArgs<P> extends Record<string, never> ? true : false;',
  );
  typeMapDefinitions.push('');
  typeMapDefinitions.push('/**');
  typeMapDefinitions.push(
    " * Makes translation arguments optional when the key doesn't require them",
  );
  typeMapDefinitions.push(
    ' * If the key has no arguments, args can be undefined',
  );
  typeMapDefinitions.push(' * If the key has arguments, args are required');
  typeMapDefinitions.push(' *');
  typeMapDefinitions.push(' * @example');
  typeMapDefinitions.push(' * ```ts');
  typeMapDefinitions.push(
    ' * // Key with no args - OptionalArgs allows undefined',
  );
  typeMapDefinitions.push(
    " * OptionalArgs<'t.success.roleAssigned'> // Record<string, never> | undefined",
  );
  typeMapDefinitions.push(' *');
  typeMapDefinitions.push(
    ' * // Key with args - OptionalArgs requires the args',
  );
  typeMapDefinitions.push(
    " * OptionalArgs<'t.errors.notFound.generic'> // { resource: string | number } (required)",
  );
  typeMapDefinitions.push(' * ```');
  typeMapDefinitions.push(' */');
  typeMapDefinitions.push('export type OptionalArgs<P extends I18nPath> =');
  typeMapDefinitions.push(
    '  IsEmptyPathArgs<P> extends true ? PathArgs<P> | undefined : PathArgs<P>;',
  );
  typeMapDefinitions.push('');
  typeMapDefinitions.push('/**');
  typeMapDefinitions.push(
    ' * Type for translation messages with type-safe arguments',
  );
  typeMapDefinitions.push(
    ' * Enforces that arguments MUST be provided when the translation key requires them',
  );
  typeMapDefinitions.push(' *');
  typeMapDefinitions.push(' * @example');
  typeMapDefinitions.push(' * ```ts');
  typeMapDefinitions.push(' * // Key with no args - args are not required');
  typeMapDefinitions.push(
    " * const msg1: TranslationMessage<'t.messages.operationSuccess'> = {",
  );
  typeMapDefinitions.push(" *   key: 't.messages.operationSuccess'");
  typeMapDefinitions.push(' * }; // ✅ Valid - no args needed');
  typeMapDefinitions.push(' *');
  typeMapDefinitions.push(' * // Key with args - args MUST be provided');
  typeMapDefinitions.push(
    " * const msg2: TranslationMessage<'t.messages.withIdNotFound'> = {",
  );
  typeMapDefinitions.push(" *   key: 't.messages.withIdNotFound'");
  typeMapDefinitions.push(' * }; // ❌ Type error - args are required');
  typeMapDefinitions.push(' *');
  typeMapDefinitions.push(
    " * const msg3: TranslationMessage<'t.messages.withIdNotFound'> = {",
  );
  typeMapDefinitions.push(" *   key: 't.messages.withIdNotFound',");
  typeMapDefinitions.push(
    ' *   args: { resource: "t.resources.user", identifier: "ID", value: "123" }',
  );
  typeMapDefinitions.push(' * }; // ✅ Valid - args provided');
  typeMapDefinitions.push(' * ```');
  typeMapDefinitions.push(' */');
  typeMapDefinitions.push(
    'export type TranslationMessage<P extends I18nPath = I18nPath> =',
  );
  typeMapDefinitions.push('  PathArgs<P> extends Record<string, never>');
  typeMapDefinitions.push('    ? { key: P }');
  typeMapDefinitions.push('    : { key: P; args: PathArgs<P> };');
  typeMapDefinitions.push('');

  // Write to file
  const typeMapOutputPath = path.join(
    __dirname,
    '../src/generated/i18n-type-map.generated.ts',
  );
  fs.writeFileSync(typeMapOutputPath, typeMapDefinitions.join('\n'), 'utf-8');

  console.log(`✅ Generated type map file`);
  console.log(`   Output: ${typeMapOutputPath}`);
}

// Run the generator
try {
  generateArgumentTypes();
} catch (error) {
  console.error('❌ Error generating argument types:', error);
  process.exit(1);
}
